 Migration Plan: In-Memory Storage to Supabase + Drizzle ORM

 Overview

 Migrate from in-memory Map storage to Supabase (hosted Postgres) with Drizzle
 ORM, while preserving NestJS API architecture and business logic.

 Current State

 - All services use in-memory Maps (AuthService, GroupsService,
 ExpensesService, SettlementsService)
 - TypeORM entities exist but are NOT connected (will be removed)
 - Socket.IO handles real-time sync via SyncGateway

 Target Architecture

 Mobile (Expo) → NestJS API → Drizzle ORM → Supabase Postgres
                     ↓
               Supabase Auth (magic links for claimed/full users)
               Supabase Storage (receipts)

 ---
 Phase 1: Supabase Project Setup

 1.1 Create Supabase Project

 1. Go to https://supabase.com and sign up/login
 2. Click "New Project"
 3. Choose organization, name project (e.g., "evn-prod"), set database password
 4. Select region closest to users (e.g., us-east-1)
 5. Wait for project to provision (~2 minutes)

 1.2 Get Project Credentials

 1. Go to Settings > API
   - Copy Project URL → SUPABASE_URL
   - Copy anon public key → SUPABASE_ANON_KEY
   - Copy service_role key → SUPABASE_SERVICE_ROLE_KEY
   - Copy JWT Secret → JWT_SECRET
 2. Go to Settings > Database
   - Enable Connection Pooling (Supavisor)
   - Copy Connection string (pooler, port 6543) → DATABASE_URL
   - Copy Connection string (direct, port 5432) → DATABASE_URL_DIRECT

 1.3 Install Dependencies

 cd apps/api
 npm install drizzle-orm postgres @supabase/supabase-js
 npm install -D drizzle-kit

 1.3 Environment Configuration

 Create apps/api/.env:
 SUPABASE_URL=https://your-project.supabase.co
 SUPABASE_ANON_KEY=your-anon-key
 SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
 DATABASE_URL=postgresql://postgres.[ref]:[pass]@pooler.supabase.com:6543/postg
 res?pgbouncer=true
 DATABASE_URL_DIRECT=postgresql://postgres.[ref]:[pass]@pooler.supabase.com:543
 2/postgres
 JWT_SECRET=your-supabase-jwt-secret

 1.4 Add package.json Scripts

 {
   "db:generate": "drizzle-kit generate",
   "db:migrate": "drizzle-kit migrate",
   "db:push": "drizzle-kit push",
   "db:studio": "drizzle-kit studio"
 }

 ---
 Phase 2: Drizzle Schema Definition

 2.1 Create Configuration

 File: apps/api/drizzle.config.ts
 import { defineConfig } from 'drizzle-kit';

 export default defineConfig({
   schema: './src/db/schema/index.ts',
   out: './src/db/migrations',
   dialect: 'postgresql',
   dbCredentials: { url: process.env.DATABASE_URL_DIRECT! },
 });

 2.2 Schema Files Structure

 apps/api/src/db/
 ├── schema/
 │   ├── index.ts          # Re-exports all schemas
 │   ├── users.ts          # users table + enums
 │   ├── groups.ts         # groups table
 │   ├── group-members.ts  # group_members junction table
 │   ├── expenses.ts       # expenses table + enums
 │   ├── expense-splits.ts # expense_splits table
 │   └── settlements.ts    # settlements table + enum
 ├── repositories/
 │   ├── index.ts
 │   ├── base.repository.ts
 │   ├── users.repository.ts
 │   ├── groups.repository.ts
 │   ├── expenses.repository.ts
 │   └── settlements.repository.ts
 ├── migrations/           # Generated by drizzle-kit
 └── db.module.ts          # NestJS module with Drizzle provider

 2.3 Schema Definitions

 users.ts - Enums: user_type (guest|claimed|full), auth_provider
 (magic_link|google|apple|guest)
 - id, supabaseAuthId (nullable, for claimed/full), email, name, type,
 authProvider
 - photoUrl, deviceId (for guests), sessionCount, upgradePromptDismissedAt
 - createdAt, updatedAt

 groups.ts
 - id, name, emoji, defaultCurrency, inviteCode (unique), isArchived
 - createdById, createdAt, updatedAt

 group_members.ts - Enum: group_role (owner|member)
 - id, userId (FK), groupId (FK), role, joinedAt
 - Unique constraint: (userId, groupId)

 expenses.ts - Enums: split_type, expense_category
 - id, groupId (FK cascade), amount, currency, description, category
 - paidById (FK), splitType, date, notes, photoUrl
 - createdById (FK), exchangeRate, createdAt, updatedAt

 expense_splits.ts
 - id, expenseId (FK cascade), userId (FK), amount, shares, percentage
 - Unique constraint: (expenseId, userId)

 settlements.ts - Enum: settlement_method
 - id, groupId (FK cascade), fromUserId (FK), toUserId (FK)
 - amount, currency, method, notes, createdById (FK), settledAt

 ---
 Phase 3: Database Module & Repositories

 3.1 DbModule (Global)

 - Provides DRIZZLE token with postgres-js client
 - Exports all repository classes
 - Configured via ConfigService for DATABASE_URL

 3.2 Repository Pattern

 Each repository extends BaseRepository:
 - UsersRepository: findById, findByEmail, findByDeviceId,
 findBySupabaseAuthId, create, update
 - GroupsRepository: CRUD + addMember, findMember, getMembers, getUserGroups,
 inviteCodeExists
 - ExpensesRepository: create (with splits in transaction), findByIdWithSplits,
  findByGroupIdWithSplits, update, delete
 - SettlementsRepository: CRUD + findByGroupId

 ---
 Phase 4: Service Migration (Order)

 4.1 GroupsService (First)

 - Replace Maps with GroupsRepository
 - Keep business logic (invite code generation)
 - Preserve SyncGateway broadcasts

 4.2 ExpensesService

 - Replace Maps with ExpensesRepository
 - Keep split calculation logic in service
 - Store splits in expense_splits table (not JSON)
 - Format response to match current API shape (splitAmounts object)

 4.3 SettlementsService

 - Replace Maps with SettlementsRepository
 - Straightforward migration

 4.4 BalancesService

 - No storage - computed from other services
 - Adapt to fetch expenses with splits from repository
 - Keep debt simplification algorithm in service

 4.5 AuthService (Last - Most Complex)

 - Integrate Supabase Auth for magic links (claimed/full users)
 - Keep guest auth in API (device-based, no Supabase Auth)
 - Hybrid flow:
   - Guest: API generates JWT, stores in users table with deviceId
   - Claimed/Full: Supabase Auth magic link → verify session → link to app user

 ---
 Phase 5: Supabase Integration

 5.1 SupabaseModule (Global)

 - Provides SUPABASE_CLIENT token
 - Uses service role key for full access
 - Auto-refresh disabled (server-side)

 5.2 Auth Flow

 1. Guest Login: POST /auth/guest → API creates user + JWT (no Supabase Auth)
 2. Magic Link: POST /auth/request-magic-link → Supabase Auth sends email
 3. Verify: POST /auth/verify → API validates Supabase session, finds/creates
 user
 4. Claim Guest: POST /auth/guest/claim → Sends magic link, on verify links
 Supabase Auth ID to existing guest user

 5.3 Storage (Receipts)

 - Create receipts bucket in Supabase Storage
 - StorageService: uploadReceipt (returns signed URL), deleteReceipt
 - Update expense photo endpoints

 ---
 Phase 6: Real-time Sync

 Recommendation: Keep Socket.IO (current SyncGateway)
 - Already integrated and working
 - Full control over event format
 - No client-side changes needed

 Future option: Supabase Realtime (requires Postgres publications, client
 changes)

 ---
 Phase 7: Testing (Local Docker Postgres)

 7.1 Docker Compose for Test Database

 Create apps/api/docker-compose.test.yml:
 version: '3.8'
 services:
   test-db:
     image: postgres:15-alpine
     environment:
       POSTGRES_USER: test
       POSTGRES_PASSWORD: test
       POSTGRES_DB: evn_test
     ports:
       - "5433:5432"
     tmpfs:
       - /var/lib/postgresql/data

 Add scripts to apps/api/package.json:
 {
   "test:db:up": "docker-compose -f docker-compose.test.yml up -d",
   "test:db:down": "docker-compose -f docker-compose.test.yml down",
   "pretest": "npm run test:db:up && npm run db:push"
 }

 7.2 Test Environment

 apps/api/.env.test:
 DATABASE_URL=postgresql://test:test@localhost:5433/evn_test
 DATABASE_URL_DIRECT=postgresql://test:test@localhost:5433/evn_test

 7.3 TestDbModule

 - Reads TEST_DATABASE_URL or falls back to local test connection
 - Provides same DRIZZLE token and repositories as production
 - clearDatabase() helper truncates all tables between tests

 7.4 Test Migration

 - Existing test patterns preserved
 - Add beforeEach to clear database
 - Use repositories to seed test data

 ---
 Phase 8: Cleanup (Post-Migration)

 1. Remove TypeORM entities from /apps/api/src/entities/
 2. Uninstall: @nestjs/typeorm, typeorm
 3. Remove in-memory Maps from services
 4. Update documentation

 ---
 Critical Files to Modify

 | File                                            | Changes
                  |
 |-------------------------------------------------|---------------------------
 -----------------|
 | apps/api/src/app.module.ts                      | Add DbModule,
 SupabaseModule imports       |
 | apps/api/src/auth/auth.service.ts               | Supabase Auth integration,
  UsersRepository |
 | apps/api/src/auth/auth.module.ts                | Add JwtModule,
 SupabaseModule              |
 | apps/api/src/groups/groups.service.ts           | Replace Maps with
 GroupsRepository         |
 | apps/api/src/expenses/expenses.service.ts       | Replace Maps with
 ExpensesRepository       |
 | apps/api/src/settlements/settlements.service.ts | Replace Maps with
 SettlementsRepository    |
 | apps/api/src/balances/balances.service.ts       | Adapt to new data format
                  |
 | packages/shared/lib/types/index.ts              | Reference for Drizzle
 schema alignment     |

 ---
 New Files to Create

 apps/api/
 ├── drizzle.config.ts
 ├── .env.example
 └── src/
     ├── db/
     │   ├── db.module.ts
     │   ├── schema/*.ts (6 files)
     │   └── repositories/*.ts (5 files)
     ├── supabase/
     │   └── supabase.module.ts
     └── storage/
         ├── storage.module.ts
         └── storage.service.ts

 ---
 Migration Order Summary

 1. Setup: Supabase project, packages, env vars, Drizzle config
 2. Schema: Define all tables in Drizzle, generate migration, push to DB
 3. Infrastructure: DbModule, SupabaseModule, repositories
 4. Services: GroupsService → ExpensesService → SettlementsService →
 BalancesService → AuthService
 5. Features: Storage service for receipts
 6. Testing: Adapt tests to use test database
 7. Cleanup: Remove TypeORM, in-memory code